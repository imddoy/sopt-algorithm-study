## 어떻게 문제에 접근했나요...?

1. (x,y)로 되어있다고 하면, x가 같을때 y가 1씩 차이나거나, y가 같을 때 x가 1씩 차이나야 이동할 수 있다...
2. 근데 그러면 2차원 배열로 입력을 받아야 하나? js에서 어떻게 2차원 배열로 입력을 받지? <br />
   => `reandline`으로 여러줄을 입력받으면 이걸 배열 형태로 반환하는 방식으로 할까?
3. 반복문을 어떻게 돌려야 효율적으로 가지? 갈 수 있는 길을 발견하면 반복문을 탈출하도록 할까?
4. 갈 수 있는 길이 여러개이면 (n,m)과 더 가까운곳을 가야하니까 일단 가기-> 막히면 다시 돌아오기로 구현해야하나? <br />
   => 계속 돌아가야 하니까 비효율적인듯....

## BFS란?

| 최단 경로 문제에서는 BFS로 접근하자!

- 너비 우선 탐색(Breadth-First Search)
- 인접한 노드를 먼저 탐색하는 알고리즘
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- **두 노드 사이의 최단 경로** 혹은 **임의의 경로**를 찾고 싶을때 선택한다 => 이 문제와 적합한 이유!!!!
- BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 **큐(Queue)를 사용**한다.
  - FIFO 원칙으로 탐색
  - 일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작
- 시간 복잡도
  - 인접 리스트로 표현된 그래프: O(N+E)
  - 인접 행렬로 표현된 그래프: O(N^2) <br />
    => 여기서 의문!! 그렇다면 2차원 배열이 아니라 리스트로 접근해야하나??? <br />
    => 미로 문제에서는 상하좌우(?)같은 형태로 이루어져 있기 때문에, E는 항상 상하좌우로 연결된 칸이므로 시간 복잡도 차이가 없어서 2차원 배열로 접근하는 것이 더 효율적인 코드인듯...!

### BFS 구현 예시 코드

```js
function BFS(graph, start, visited) {
  const queue = new Queue();
  queue.push(start);
  visited[start] = true;

  while (queue.size()) {
    const v = queue.popleft();
    console.log(v);

    for (const node of graph[v]) {
      if (!visited[node]) {
        queue.push(node);
        visited[node] = true;
      }
    }
  }
}

const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(6).fill(false);
BFS(graph, 0, visited);
// 0 1 2 4 5 3
```

## 어떻게 풀었나요?

1. 입력을 받아서 2차원 배열로 저장하기
2. queue를 만들어서 거리를 계산할 수 있도록 하기
3. BFS로 반복문 처리하기
   - queue가 빌 때까지
   - 인접한 칸을 순차적으로 탐색하기
   - 갈 수 있는 방향을 배열로 처리해서 반복문으로 하나씩 확인하기
   - 목표에 도착했다면 끝, 도착하지 못했다면 지금 지점에서 다시 탐색하도록 반복

## 어려웠던 부분

- 큐를 구현한다는 것을 해보지 못했어서 어려웠는데, 그냥 배열을 큐처럼 넣고 빼면 되는듯. shift랑 push를 사용해서 접근하는 방식으로 해결함.
