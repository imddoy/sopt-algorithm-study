## 어떻게 문제에 접근했나요...?

1. 종이를 나누는 모든 경우의 수를 어떻게 확인하지...????? 가로조각이랑 세로조각 분류하는 기준....???? => 비트마스크 순회하고 최댓값 구하기

## 비트마스크

- 비트로 표현하여 특정 상태를 관리하거나 계산을 수행하는 기술
- 주로 비트 연산을 활용하여 효율적으로 데이터를 처리하거나, 모든 가능한 경우의 수를 탐색할 때 사용
- 비트 연산이기때문에 빠르고 O(1) 시간복잡도를 갖는 경우가 많음
- 정수 하나로 여러 상태 저장 가능
- N개의 상태에 대해 2^N개의 조합 쉽게 표현 가능

  - 0: off 상태 / 1: on 상태
  - ex) 0b0001: 1번 상태만 켜짐. / 0b0101: 1번, 3번 상태 켜짐. / 0b1111: 모든 상태 켜짐.

## 어떻게 풀었나요?

- 가로 조각이랑 세로 조각의 계산 방식이 다르니 가로랑 세로를 비트로 각각 0과 1로 상태 설정해야 함

  - 0부터 2^(N\*M) -1까지의 비트마스크를 순회하며 각 칸을 가로, 세로 조각으로 분류

- 가로 조각 세로 조각일 때 각각 알맞게 계산
  - `rowSum = rowSum * 10 + parseInt(paper[i][j]);` 계속 값을 1의 자리수에 넣음음

## 어려웠던 부분

- 비트마스크로 상태 확인하는 법

  - `(mask & (1<<index))` 특정 index의 비트만 1로 설정한 값이랑 mask를 AND 연산을 수행하면 해당 위치 이외의 비트는 0이 되고, index 위치가 1로 켜져있으면 해당 위치의 값 2^index 반환
