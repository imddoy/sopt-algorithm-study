## 어떻게 문제에 접근했나요...?

1. N\*N 크기의 2차원 배열을 만들고, 가장 작은 값과 큰값을 찾아 범위를 만들고 그 범위만큼 반복해서 안전구역 수를 찾으면 되는건가?
2. 모든 노드를 탐색해야하니까 DFS가 적합할듯..?
3. 일단 안전구역을 찾은 다음에 반복해서 이어진 구역을 찾으면 되겠다!!
4. 모든 찾기가 끝나면 가장 큰 값을 출력하면 될듯

## DFS란?

| 모든 노드를 방문할 때 DFS로 접근하자!

- 깊이 우선 탐색(Depth-First Search)
- 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 알고리즘
- 넓게 탐색하기 전에 깊게 탐색
- 자기 자신을 호출하는 **순환 알고리즘**
- **어떤 노드를 방문했었는지 여부를 반드시 검사해야 함**
- 구현 방법 2가지
  1. 순환 호출 이용
     - 동작 방식
       - 방문 여부를 기록하기 위해 배열 visited를 사용하며, 배열 visited의 값을 false로 초기화한다.
       - 노드를 방문할 때마다 해당 노드의 visited 배열 값을 true로 변경한다.
       - 해당 노드(v)와 연결된 노드 중에 방문하지 않은 노드(node)이 있다면 방문하지 않은 노드(node)를 시작점으로 하여 DFS를 다시 시작한다.
  2. 명시적인 스택 사용: 명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업
     - 스택에 시작 노드를 push 한다.
     - 스택에서 노드를 pop하고 해당 노드(v)가 방문하지 않은 노드라면 방문처리 한다.
     - 노드(v)와 연결된 노드 중에서 방문하지 않은 노드(node)이 있다면 stack에 push 한다.
     - 스택의 길이가 0이 될 때까지 2, 3번 과정을 반복한다.
- 시간 복잡도
  - 인접 리스트: O(N+E)
  - 인접 행렬: O(N^2)

### DFS 구현 예시 코드

- 재귀(순환 호출)

```js
function dfs(graph, v, visited) {
  // 현재 노드를 방문 처리
  visited[v] = true;
  console.log(v);

  // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for (let node of graph[v]) {
    if (!visited[node]) {
      dfs(graph, node, visited);
    }
  }
}

const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
// 0 1 5 2 4 3
```

- 스택

```js
function dfs(graph, start, visited) {
  const stack = [];
  stack.push(start);

  while (stack.length) {
    let v = stack.pop();
    if (!visited[v]) {
      console.log(v);
      visited[v] = true;

      for (let node of graph[v]) {
        if (!visited[node]) {
          stack.push(node);
        }
      }
    }
  }
}
const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
// 0 4 3 2 5 1
```

## 어떻게 풀었나요?

1. 입력 값에서 확인 범위를 받아오기
2. 지역 높이를 2차원 배열로 저장하기
3. 안전구역 탐색하도록 반복문

   - 범위보다 높은 지역 발견하면 안전구역 수 증가
   - 인접한 높은 지역 찾기 => 높은 지역 없을 때까지 반복문
     - 여기서는 동일한 안전구역이기 때문에 새로 안전구역 수를 증가할 필요없음

=> 총 2개의 반복문 사용

## 어려웠던 부분

- 2차원 배열을 max값을 찾아야 해서 `flat()`을 사용해야 햇음
- region값을 방문했다고 바로 값을 수정하면, 다음 범위에서 변경된 값을 탐색하게 되어서 범위마다 새로 배열을 만들어서 탐색 여부를 확인해야 했음
- min부터 반복하면 모든 높이가 같은 지역의 경우 안전구역이 0으로 계산되었음... 그래서 0부터 범위를 설정해야 했음
