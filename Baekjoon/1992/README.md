## 어떻게 문제에 접근했나요...?

1. 일단 크기만큼 n\*n의 배열에 입력값을 2차원 배열로 저장하고 그걸 이제 구역을 나눠서 판단해야겠지?
2. 그러면 이제 차례대로 판단할텐데..... 기준 idx를 잡아서 오른쪽, 아래쪽, 오른쪽 아래 대각선쪽 이렇게 접근해서 값을 판단하기를 반복하면 되려나...?

   2-1. 그럼 그 기준은 어떻게 잡지.. 0,0 2,0 ... 2,n-1까지랑 0,0 0,2 ... 0,n-1까지?

   2-2. 그러면 접근해서 숫자가 다 같으면 그 값으로 하나로 처리하고 다르면 모든값을 하나로 묶기...? <br />
   => 구조의 특성을 살려서 하나의 2차원 배열을 가로 세로 절반씩을 계속 나눠주면서 각 구역을 들어가서 같은 값 여부 탐색을 반복하기 근데 이제 왼쪽 위 구역부터 차례대로...

3. ()로 묶는건 어떻게 묶어야 하나...일단 `(`로 열고 다른값이 나오면 그 값이 끝날때 `)`로 감싸주면 되나? <br />
   => 아 4개 값을 ()로 감싸고 있는거구나...

## DFS란?

| 모든 노드를 방문할 때 DFS로 접근하자!

- 깊이 우선 탐색(Depth-First Search)
- 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 알고리즘
- 넓게 탐색하기 전에 깊게 탐색
- 자기 자신을 호출하는 **순환 알고리즘**
- **어떤 노드를 방문했었는지 여부를 반드시 검사해야 함**
- 구현 방법 2가지
  1. 순환 호출 이용
     - 동작 방식
       - 방문 여부를 기록하기 위해 배열 visited를 사용하며, 배열 visited의 값을 false로 초기화한다.
       - 노드를 방문할 때마다 해당 노드의 visited 배열 값을 true로 변경한다.
       - 해당 노드(v)와 연결된 노드 중에 방문하지 않은 노드(node)이 있다면 방문하지 않은 노드(node)를 시작점으로 하여 DFS를 다시 시작한다.
  2. 명시적인 스택 사용: 명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업
     - 스택에 시작 노드를 push 한다.
     - 스택에서 노드를 pop하고 해당 노드(v)가 방문하지 않은 노드라면 방문처리 한다.
     - 노드(v)와 연결된 노드 중에서 방문하지 않은 노드(node)이 있다면 stack에 push 한다.
     - 스택의 길이가 0이 될 때까지 2, 3번 과정을 반복한다.
- 시간 복잡도
  - 인접 리스트: O(N+E)
  - 인접 행렬: O(N^2)

### DFS 구현 예시 코드

- 재귀(순환 호출)

```js
function dfs(graph, v, visited) {
  // 현재 노드를 방문 처리
  visited[v] = true;
  console.log(v);

  // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for (let node of graph[v]) {
    if (!visited[node]) {
      dfs(graph, node, visited);
    }
  }
}

const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
// 0 1 5 2 4 3
```

- 스택

```js
function dfs(graph, start, visited) {
  const stack = [];
  stack.push(start);

  while (stack.length) {
    let v = stack.pop();
    if (!visited[v]) {
      console.log(v);
      visited[v] = true;

      for (let node of graph[v]) {
        if (!visited[node]) {
          stack.push(node);
        }
      }
    }
  }
}
const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
// 0 4 3 2 5 1
```

## 어떻게 풀었나요?

1. 구역의 모든값이 같으면 값을 반환하고 다르면 나오기 반복

   1-1. 다른 값이 있다면 구역을 가로 세로를 각각 반으로 자르면서 구역에 접근해서 같은값만 있을 때까지 반복(값이 다 다르다면 구역의 크기가 1이 될 수도 있음!)

## 어려웠던 부분

- ()를 넣는 타이밍을 잡기 어려웠는데, 같은 값이 나오면 (를 넣고 그 구역의 값 찾기가 다 끝나면 )로 감싸도록 타이밍을 잡음
